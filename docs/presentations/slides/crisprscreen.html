<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>crisprscreen.utf8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# CrispR screen analysis using R and Bioconductor
<html>
<div style="float:left">

</div>
<hr color='#EB811B' size=1px width=796px>
</html>
### Rockefeller University, Bioinformatics Resource Centre
### <a href="http://rockefelleruniversity.github.io/Bioconductor_Introduction/" class="uri">http://rockefelleruniversity.github.io/Bioconductor_Introduction/</a>

---









## Highthroughput Crispr Screening 

---
## Analysis of Crispr screens


---
## Tools for analysis

[PinAPL-Py: A comprehensive web-application for the analysis of CRISPR/Cas9 screens](https://www.nature.com/articles/s41598-017-16193-9)

[MAGeCK enables robust identification of essential genes from genome-scale CRISPR/Cas9 knockout screens](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0554-4)

---
## PinAPL-Py


SRP123360


---
## Download the data

https://github.com/LewisLabUCSD/PinAPL-Py.

https://github.com/LewisLabUCSD/PinAPL-Py/archive/master.zip


```r
download.file("https://github.com/LewisLabUCSD/PinAPL-Py/archive/master.zip","pieappleData.zip")
unzip("pieappleData.zip")
```


---
## Quality control of FastQ

Once we have downloaded the raw fastQ data (either from their Gtihub or from SRA) we can use the [ShortRead package](https://bioconductor.org/packages/release/bioc/html/ShortRead.html) to review our sequence data quality.

We have reviewed how to work with raw sequencing data in the [**FastQ in Bioconductor** session.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#1)

First we load the [ShortRead library.](https://bioconductor.org/packages/release/bioc/html/ShortRead.html)





```r
library(ShortRead)
```

---
## Working with FQs from Crispr screen.

First we will review the raw sequencing reads using functions in the [ShortRead package.](https://bioconductor.org/packages/release/bioc/html/ShortRead.html) This is similar to our QC we performed for RNAseq and ChIPseq. 

We do not need to review all reads in the file to can gain an understanding of data quality. We can simply review a subsample of the reads and save ourselves some time and memory.

**Remember** when we subsample we retrieve random reads from across the entire fastQ file. This is important as fastQ files are often ordered by their position on the sequencer.

---
## Crispr screen FQs.

We can subsample from a fastQ file using functions in **ShortRead** package.

Here we use the [**FastqSampler** and **yield** function](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#41) to randomly sample a defined number of reads from a fastQ file. Here we subsample 1 million reads.


```r
fqSample &lt;- FastqSampler("PinAPL-Py-master/Data/Tox-A_R01_98_S2_L008_R1_001_x.fastq.gz",n=10^6)
fastq &lt;- yield(fqSample)
```

---
## Working with raw ChIPseq data

The resulting object is a [ShortReadQ object](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#10) showing information on the number of cycles, base pairs in reads, and number of reads in memory.


```r
fastq
```

```
## class: ShortReadQ
## length: 500000 reads; width: 50 cycles
```

---

## Raw ChIPseq data QC

If we wished, we can assess information from the fastQ file using our [familiar accessor functions.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#15)

* **sread()** - Retrieve sequence of reads.
* **quality()** - Retrieve quality of reads as ASCI scores.
* **id()** - Retrieve IDs of reads.




```r
readSequences &lt;- sread(fastq)
readQuality &lt;- quality(fastq)
readIDs &lt;- id(fastq)
readSequences
```

```
## DNAStringSet object of length 500000:
##          width seq
##      [1]    50 TCGAATCTTGTGGAAATGACGAAACACAGCCCTTGACATGACAATTGTGG
##      [2]    50 TCGAATCTTGTGGAAAGGACGAAACACCGAAGAGGAATAACCCGGCCTGG
##      [3]    50 TCGAATCTTGTGGAAAGGACGAAACGCAGACAATCCCCCCCCTGACATAG
##      [4]    50 TCGAATCTTGTGGAAAGGGCGAAACACTGCTGGTCGAGGCGTTCCGCATG
##      [5]    50 TCGAATCTTGTGGAAAGAGGAAACACCGAGCCATCCCAGCCCACTAGCGG
##      ...   ... ...
## [499996]    50 TCGAATCTTGTGGAAAGGACGAAACACCGGCTTCTTGTCCGCGCGCACGG
## [499997]    50 TCGAATCTTGTGGAAAGGACGAAACACCGCCCCAGACGGAAGCTCATGTG
## [499998]    50 TCGAATCTTGTGGAAAGGACGAAACACCGTGATGAATTCAGCTTTCCGGT
## [499999]    50 TCGAATCTTGTGGAAAGGACGAAACACCGAGTGCAATTGCAAGGTCATAG
## [500000]    50 TCGAATCTTGTGGAAAGGACGAAACACCATGTCCGTGTCACAACTTTGTT
```

---
## Quality with raw ChIPseq data

We can check some simple quality metrics for our subsampled fastQ data.

First, we can review the overall reads' quality scores.

We use the [**alphabetScore()** function with our read's qualitys](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#28) to retrieve the sum quality for every read from our subsample.




```r
readQuality &lt;- quality(fastq)
readQualities &lt;- alphabetScore(readQuality)
readQualities[1:10]
```

```
##  [1] 1282 1254 1095 1239 1382 1408 1324 1325 1318 1474
```

---

## Quality with raw ChIPseq data

We can then produce a histogram of quality scores to get a better understanding of the distribution of scores.


```r
library(ggplot2)
toPlot &lt;- data.frame(ReadQ=readQualities)
ggplot(toPlot,aes(x=ReadQ))+geom_histogram()+theme_minimal()
```

```
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

![](crisprscreen_files/figure-html/mycRep1ReadsQScoresPlot-1.png)&lt;!-- --&gt;


---

## Base frequency with raw ChIPseq data

We can review the occurrence of DNA bases within reads and well as the occurrence of DNA bases across sequencing cycles using the [**alphabetFrequency()**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#18) and [**alphabetByCycle()**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#30) functions respectively.

Here we check the overall frequency of **A, G, C, T and N (unknown bases)** in our sequence reads.


```r
readSequences &lt;- sread(fastq)
readSequences_AlpFreq &lt;- alphabetFrequency(readSequences)
readSequences_AlpFreq[1:3,]
```

```
##       A  C  G  T M R W S Y K V H D B N - + .
## [1,] 16 10 12 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [2,] 17 11 15  7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [3,] 16 15 11  8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


---

## Base frequency with raw ChIPseq data

Once we have the frequency of DNA bases in our sequence reads we can retrieve the sum across all reads.


```r
summed__AlpFreq  &lt;- colSums(readSequences_AlpFreq)
summed__AlpFreq[c("A","C","G","T","N")]
```

```
##       A       C       G       T       N 
## 7275781 6043883 6564129 5105990   10217
```

---

## Assess by cycle with raw ChIPseq data

We can review DNA base occurrence by cycle using the [**alphabetByCycle()** function.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#30)


```r
readSequences_AlpbyCycle &lt;- alphabetByCycle(readSequences)
readSequences_AlpbyCycle[1:4,1:10]
```

```
##         cycle
## alphabet   [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]  [,10]
##        A    374   7816   9634 482525 481226    257    203    172    189    241
##        C   9077 482302   7821    538   7954   9864 481477    336    248    132
##        G   7630   9323 481741   9073    750    131    482   7825  10814 488911
##        T 473741    559    804   7864  10058 489748  17838 491667 488749  10716
```

---

## Assess by cycle with raw ChIPseq data

We often plot this to visualise the base occurrence over cycles to observe any bias.
First we arrange the base frequency into a data frame.


```r
AFreq &lt;- readSequences_AlpbyCycle["A",]
CFreq &lt;- readSequences_AlpbyCycle["C",]
GFreq &lt;- readSequences_AlpbyCycle["G",]
TFreq &lt;- readSequences_AlpbyCycle["T",]
toPlot &lt;- data.frame(Count=c(AFreq,CFreq,GFreq,TFreq),
                     Cycle=rep(1:max(width(readSequences)),4),
                     Base=rep(c("A","C","G","T"),each=max(width(readSequences))))
```

---

## Assess by cycle with raw ChIPseq data

Now we can plot the frequencies using ggplot2


```r
ggplot(toPlot,aes(y=Count,x=Cycle,colour=Base))+geom_line()+
  theme_bw()
```

![](crisprscreen_files/figure-html/mycRep1ReadsAlpByCyclePlot2-1.png)&lt;!-- --&gt;

---

## Assess by cycle with raw ChIPseq data

We can also assess mean read quality over cycles. This will allow us to identify whether there are any isses with quality dropping off over time.

For this we use the [**as(*read_quality*,"matrix")**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#29) function first to translate our ASCI quality scores to numeric quality scores.


```r
qualAsMatrix &lt;- as(readQuality,"matrix")
qualAsMatrix[1:2,]
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## [1,]   32   32   12   32   37   41   37   41   41    22    32    37    37    32
## [2,]   32   27   32   32   32   32   37   37   41    27    37    32    37    37
##      [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]
## [1,]    12    37    12    32    32    27    22    27    37    27    22    27
## [2,]    12    32    37    32    12    12    32    22    22    12    27    27
##      [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]
## [1,]    12    12    27    12    22    12    22    22    12    12    12    27
## [2,]    22    27    22    22    37    12    27    37    22    27    22    12
##      [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
## [1,]    27    12    22    37    37    37    37    27    12    12    12    27
## [2,]    22    12    27    12    27    12    22    22    12    12    12    22
```

---

## Assess by cycle with raw ChIPseq data

We can now [visualise qualities across cycles using a boxplot.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/exercises/answers/fastq_answers.html)


```r
toPlot &lt;- colMeans(qualAsMatrix)
plot(toPlot)
```

![](crisprscreen_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---

## Assess by cycle with raw ChIPseq data

In this case the distribution of reads quality scores and read qualities over time look okay. We will often want to access fastQ samples together to see if any samples stick out by these metrics.

Here we observed a second population of low quality scores so will remove some reads with low quality scores and high unknown bases.



---
class: inverse, center, middle

# Aligning data

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Aligning ChIPseq reads

Following assessment of read quality and any read filtering we applied, we will want to align our reads to the genome so as to identify any genomic locations showing enrichment for aligned reads above background.

Since ChIPseq reads will align continously against our reference genome we can use [our genomic aligners we have seen in previous sessions.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignmentInBioconductor.html#7) The resulting BAM file will contain aligned sequence reads for use in further analysis.

&lt;div align="center"&gt;
&lt;img src="imgs/sam2.png" alt="igv" height="200" width="600"&gt;
&lt;/div&gt;

---
## Creating a sgRNA reference

First we need to retrieve the sequence information for the sgRNA guides of interest in [FASTA format](https://rockefelleruniversity.github.io/Genomic_Data/presentations/slides/GenomicsData.html#9)

We can read the sequences of our sgRNA probes from the TSV file downloaded from the Github page [here](http://pinapl-py.ucsd.edu/example-data).


```r
download.file("http://pinapl-py.ucsd.edu/example-data","TestData.zip")
unzip("TestData.zip")
```

---
## Creating a sgRNA reference

First we need to retrieve the sequence information for the sgRNA guides of interest in [FASTA format](https://rockefelleruniversity.github.io/Genomic_Data/presentations/slides/GenomicsData.html#9)

We can read the sequences of our sgRNA probes from the TSV file downloaded from the Github page [here](http://pinapl-py.ucsd.edu/example-data).


```r
GeCKO &lt;- read.delim("PinAPL-py_demo_data/GeCKOv21_Human.tsv")
GeCKO[1:2,]
```

```
##   gene_id          UID                  seq
## 1    A1BG HGLibA_00001 GTCGCTGAGCTCCGATTCGA
## 2    A1BG HGLibA_00002 ACCTGTAGTTGCCGGCGTGC
```


---
## Creating a sgRNA fasta

Now we can create a [**DNAStringSet** object from the retrieved sequences](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/SequencesInBioconductor.html#17) as we have done for full chromosome sequences.


```r
require(Biostrings)
sgRNAs &lt;- DNAStringSet(GeCKO$seq)
names(sgRNAs) &lt;- GeCKO$UID
```


---
## Creating a sgRNA fasta


Now we have a **DNAStringSet** object we can use the [**writeXStringSet** to create our FASTA file of sequences to align to.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/SequencesInBioconductor.html#22)


```r
writeXStringSet(sgRNAs,
                file="GeCKO.fa")
```

http://pinapl-py.ucsd.edu/example-results


---
## Creating an Rsubread index 

We will be aligning using the **subjunc** algorithm from the authors of subread. We can therefore use the **Rsubread** package. Before we attempt to align our fastq files, we will need to first build an index from our reference genome using the **buildindex()** function.

The [**buildindex()** function simply takes the parameters of our desired index name and the FASTA file to build index from.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignmentInBioconductor.html#14)


Luckily we did this for RNAseq, so hopefully you will already have a built index. 

```r
library(Rsubread)
buildindex("GeCKO","GeCKO.fa", 
           indexSplit=FALSE)
```

```
## 
##         ==========     _____ _    _ ____  _____  ______          _____  
##         =====         / ____| |  | |  _ \|  __ \|  ____|   /\   |  __ \ 
##           =====      | (___ | |  | | |_) | |__) | |__     /  \  | |  | |
##             ====      \___ \| |  | |  _ &lt;|  _  /|  __|   / /\ \ | |  | |
##               ====    ____) | |__| | |_) | | \ \| |____ / ____ \| |__| |
##         ==========   |_____/ \____/|____/|_|  \_\______/_/    \_\_____/
##        Rsubread 2.2.6
## 
## //================================= setting ==================================\\
## ||                                                                            ||
## ||                Index name : GeCKO                                          ||
## ||               Index space : base space                                     ||
## ||               Index split : no-split                                       ||
## ||          Repeat threshold : 100 repeats                                    ||
## ||              Gapped index : no                                             ||
## ||                                                                            ||
## ||       Free / total memory : 4.9GB / 6.8GB                                  ||
## ||                                                                            ||
## ||               Input files : 1 file in total                                ||
## ||                             o GeCKO.fa                                     ||
## ||                                                                            ||
## \\============================================================================//
## 
## //================================= Running ==================================\\
## ||                                                                            ||
## || Check the integrity of provided reference sequences ...                    ||
## || No format issues were found                                                ||
## || Scan uninformative subreads in reference sequences ...                     ||
## || Estimate the index size...                                                 ||
## || 1.4 GB of memory is needed for index building.                             ||
## || Build the index...                                                         ||
## || Save current index block...                                                ||
## ||  [ 0.0% finished ]                                                         ||
## ||  [ 10.0% finished ]                                                        ||
## ||  [ 20.0% finished ]                                                        ||
## ||  [ 30.0% finished ]                                                        ||
## ||  [ 40.0% finished ]                                                        ||
## ||  [ 50.0% finished ]                                                        ||
## ||  [ 60.0% finished ]                                                        ||
## ||  [ 70.0% finished ]                                                        ||
## ||  [ 80.0% finished ]                                                        ||
## ||  [ 90.0% finished ]                                                        ||
## ||  [ 100.0% finished ]                                                       ||
## ||                                                                            ||
## ||                      Total running time: 0.2 minutes.                      ||
## ||                    Index GeCKO was successfully built.                     ||
## ||                                                                            ||
## \\============================================================================//
```


---
## Rsubread ChIPseq alignment

We can align our raw sequence data in fastQ format to the new FASTA file of our mm10 genome sequence using the **Rsubread** package. Specifically we will be using the **align** function as this utilizes the subread genomic alignment algorithm. 

The [**align()** function accepts arguments for the index to align to, the fastQ to align, the name of output BAM, the mode of alignment (rna or dna) and the phredOffset.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/AlignmentInBioconductor.html#15)



```r
myFQs &lt;- "PinAPL-py_demo_data/Control_R1_S14_L008_R1_001_x.fastq.gz"
myMapped &lt;- align("GeCKO",myFQs,output_file = gsub(".fastq.gz",".bam",myFQs),
                  nthreads=4,unique=TRUE,nBestLocations=1,type = "DNA")
```

```
## 
##         ==========     _____ _    _ ____  _____  ______          _____  
##         =====         / ____| |  | |  _ \|  __ \|  ____|   /\   |  __ \ 
##           =====      | (___ | |  | | |_) | |__) | |__     /  \  | |  | |
##             ====      \___ \| |  | |  _ &lt;|  _  /|  __|   / /\ \ | |  | |
##               ====    ____) | |__| | |_) | | \ \| |____ / ____ \| |__| |
##         ==========   |_____/ \____/|____/|_|  \_\______/_/    \_\_____/
##        Rsubread 2.2.6
## 
## //================================= setting ==================================\\
## ||                                                                            ||
## || Function      : Read alignment (DNA-Seq)                                   ||
## || Input file    : Control_R1_S14_L008_R1_001_x.fastq.gz                      ||
## || Output file   : Control_R1_S14_L008_R1_001_x.bam (BAM)                     ||
## || Index name    : GeCKO                                                      ||
## ||                                                                            ||
## ||                    ------------------------------------                    ||
## ||                                                                            ||
## ||                               Threads : 4                                  ||
## ||                          Phred offset : 33                                 ||
## ||                             Min votes : 3 / 10                             ||
## ||                        Max mismatches : 3                                  ||
## ||                      Max indel length : 5                                  ||
## ||            Report multi-mapping reads : no                                 ||
## || Max alignments per multi-mapping read : 1                                  ||
## ||                                                                            ||
## \\============================================================================//
## 
## //================= Running (24-Aug-2020 16:59:38, pid=6141) =================\\
## ||                                                                            ||
## || Check the input reads.                                                     ||
## || The input file contains base space reads.                                  ||
## || Initialise the memory objects.                                             ||
## || Estimate the mean read length.                                             ||
## || The range of Phred scores observed in the data is [2,41]                   ||
## || Create the output BAM file.                                                ||
## || Check the index.                                                           ||
## || Init the voting space.                                                     ||
## || Global environment is initialised.                                         ||
## || Load the 1-th index block...                                               ||
## || The index block has been loaded.                                           ||
## || Start read mapping in chunk.                                               ||
## ||    5% completed, 0.4 mins elapsed, rate=166.5k reads per second            ||
## ||   12% completed, 0.4 mins elapsed, rate=197.5k reads per second            ||
## ||   18% completed, 0.4 mins elapsed, rate=209.9k reads per second            ||
## ||   26% completed, 0.4 mins elapsed, rate=210.7k reads per second            ||
## ||   32% completed, 0.4 mins elapsed, rate=214.1k reads per second            ||
## ||   39% completed, 0.4 mins elapsed, rate=216.5k reads per second            ||
## ||   45% completed, 0.4 mins elapsed, rate=219.6k reads per second            ||
## ||   51% completed, 0.4 mins elapsed, rate=221.4k reads per second            ||
## ||   59% completed, 0.5 mins elapsed, rate=223.1k reads per second            ||
## ||   63% completed, 0.5 mins elapsed, rate=223.0k reads per second            ||
## ||   70% completed, 0.5 mins elapsed, rate=12.8k reads per second             ||
## ||   73% completed, 0.5 mins elapsed, rate=13.3k reads per second             ||
## ||   76% completed, 0.5 mins elapsed, rate=13.9k reads per second             ||
## ||   80% completed, 0.5 mins elapsed, rate=14.4k reads per second             ||
## ||   82% completed, 0.5 mins elapsed, rate=14.7k reads per second             ||
## ||   84% completed, 0.5 mins elapsed, rate=15.2k reads per second             ||
## ||   87% completed, 0.5 mins elapsed, rate=15.6k reads per second             ||
## ||   91% completed, 0.5 mins elapsed, rate=16.2k reads per second             ||
## ||   94% completed, 0.5 mins elapsed, rate=16.8k reads per second             ||
## ||   98% completed, 0.5 mins elapsed, rate=17.3k reads per second             ||
## ||                                                                            ||
## ||                           Completed successfully.                          ||
## ||                                                                            ||
## \\====================================    ====================================//
## 
## //================================   Summary =================================\\
## ||                                                                            ||
## ||                 Total reads : 500,000                                      ||
## ||                      Mapped : 0 (0.0%)                                     ||
## ||             Uniquely mapped : 0                                            ||
## ||               Multi-mapping : 0                                            ||
## ||                                                                            ||
## ||                    Unmapped : 500,000                                      ||
## ||                                                                            ||
## ||                      Indels : 0                                            ||
## ||                                                                            ||
## ||                Running time : 0.5 minutes                                  ||
## ||                                                                            ||
## \\============================================================================//
```

---
## Rsubread ChIPseq alignment


```r
myMapped 
```

```
##                       Control_R1_S14_L008_R1_001_x.bam
## Total_reads                                     500000
## Mapped_reads                                         0
## Uniquely_mapped_reads                                0
## Multi_mapping_reads                                  0
## Unmapped_reads                                  500000
## Indels                                               0
```

---
## Rsubread ChIPseq alignment

We can align our raw sequence data in fastQ format to the new FASTA file of our mm10 genome sequence using the **Rsubread** package. Specifically we will be using the **align** function as this utilizes the subread genomic alignment algorithm. 

The [**align()** function accepts arguments for the index to align to, the fastQ to align, the name of output BAM, the mode of alignment (rna or dna) and the phredOffset.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/AlignmentInBioconductor.html#15)



```r
myFQs &lt;- "PinAPL-py_demo_data/Control_R1_S14_L008_R1_001_x.fastq.gz"
myMapped &lt;- align("GeCKO",myFQs,output_file = gsub(".fastq.gz",".bam",myFQs),
                  nthreads=4,unique=TRUE,nBestLocations=1,type = "DNA",TH1 = 1)
```

```
## 
##         ==========     _____ _    _ ____  _____  ______          _____  
##         =====         / ____| |  | |  _ \|  __ \|  ____|   /\   |  __ \ 
##           =====      | (___ | |  | | |_) | |__) | |__     /  \  | |  | |
##             ====      \___ \| |  | |  _ &lt;|  _  /|  __|   / /\ \ | |  | |
##               ====    ____) | |__| | |_) | | \ \| |____ / ____ \| |__| |
##         ==========   |_____/ \____/|____/|_|  \_\______/_/    \_\_____/
##        Rsubread 2.2.6
## 
## //================================= setting ==================================\\
## ||                                                                            ||
## || Function      : Read alignment (DNA-Seq)                                   ||
## || Input file    : Control_R1_S14_L008_R1_001_x.fastq.gz                      ||
## || Output file   : Control_R1_S14_L008_R1_001_x.bam (BAM)                     ||
## || Index name    : GeCKO                                                      ||
## ||                                                                            ||
## ||                    ------------------------------------                    ||
## ||                                                                            ||
## ||                               Threads : 4                                  ||
## ||                          Phred offset : 33                                 ||
## ||                             Min votes : 1 / 10                             ||
## ||                        Max mismatches : 3                                  ||
## ||                      Max indel length : 5                                  ||
## ||            Report multi-mapping reads : no                                 ||
## || Max alignments per multi-mapping read : 1                                  ||
## ||                                                                            ||
## \\============================================================================//
## 
## //================= Running (24-Aug-2020 17:00:06, pid=6141) =================\\
## ||                                                                            ||
## || Check the input reads.                                                     ||
## || The input file contains base space reads.                                  ||
## || Initialise the memory objects.                                             ||
## || Estimate the mean read length.                                             ||
## || The range of Phred scores observed in the data is [2,41]                   ||
## || Create the output BAM file.                                                ||
## || Check the index.                                                           ||
## || Init the voting space.                                                     ||
## || Global environment is initialised.                                         ||
## || Load the 1-th index block...                                               ||
## || The index block has been loaded.                                           ||
## || Start read mapping in chunk.                                               ||
## ||    5% completed, 0.4 mins elapsed, rate=179.6k reads per second            ||
## ||   11% completed, 0.4 mins elapsed, rate=199.9k reads per second            ||
## ||   17% completed, 0.4 mins elapsed, rate=212.0k reads per second            ||
## ||   23% completed, 0.4 mins elapsed, rate=217.1k reads per second            ||
## ||   30% completed, 0.4 mins elapsed, rate=218.9k reads per second            ||
## ||   36% completed, 0.5 mins elapsed, rate=220.3k reads per second            ||
## ||   43% completed, 0.5 mins elapsed, rate=222.9k reads per second            ||
## ||   50% completed, 0.5 mins elapsed, rate=224.4k reads per second            ||
## ||   56% completed, 0.5 mins elapsed, rate=224.5k reads per second            ||
## ||   63% completed, 0.5 mins elapsed, rate=224.6k reads per second            ||
## ||   70% completed, 0.5 mins elapsed, rate=12.5k reads per second             ||
## ||   73% completed, 0.5 mins elapsed, rate=13.0k reads per second             ||
## ||   76% completed, 0.5 mins elapsed, rate=13.4k reads per second             ||
## ||   79% completed, 0.5 mins elapsed, rate=13.9k reads per second             ||
## ||   83% completed, 0.5 mins elapsed, rate=14.4k reads per second             ||
## ||   85% completed, 0.5 mins elapsed, rate=14.7k reads per second             ||
## ||   88% completed, 0.5 mins elapsed, rate=15.1k reads per second             ||
## ||   91% completed, 0.5 mins elapsed, rate=15.5k reads per second             ||
## ||   95% completed, 0.5 mins elapsed, rate=16.0k reads per second             ||
## ||   98% completed, 0.5 mins elapsed, rate=16.4k reads per second             ||
## ||                                                                            ||
## ||                           Completed successfully.                          ||
## ||                                                                            ||
## \\====================================    ====================================//
## 
## //================================   Summary =================================\\
## ||                                                                            ||
## ||                 Total reads : 500,000                                      ||
## ||                      Mapped : 421,608 (84.3%)                              ||
## ||             Uniquely mapped : 421,608                                      ||
## ||               Multi-mapping : 0                                            ||
## ||                                                                            ||
## ||                    Unmapped : 78,392                                       ||
## ||                                                                            ||
## ||                      Indels : 0                                            ||
## ||                                                                            ||
## ||                Running time : 0.5 minutes                                  ||
## ||                                                                            ||
## \\============================================================================//
```

---
## Rsubread ChIPseq alignment


```r
myMapped 
```

```
##                       Control_R1_S14_L008_R1_001_x.bam
## Total_reads                                     500000
## Mapped_reads                                    421608
## Uniquely_mapped_reads                           421608
## Multi_mapping_reads                                  0
## Unmapped_reads                                   78392
## Indels                                               0
```



---
## Rsubread ChIPseq alignment

We can align our raw sequence data in fastQ format to the new FASTA file of our mm10 genome sequence using the **Rsubread** package. Specifically we will be using the **align** function as this utilizes the subread genomic alignment algorithm. 

The [**align()** function accepts arguments for the index to align to, the fastQ to align, the name of output BAM, the mode of alignment (rna or dna) and the phredOffset.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/AlignmentInBioconductor.html#15)



```r
myFQs &lt;- "PinAPL-py_demo_data/Control_R1_S14_L008_R1_001_x.fastq.gz"
myMapped &lt;- align("GeCKO",myFQs,output_file = gsub(".fastq.gz",".bam",myFQs),
                  nthreads=4,unique=TRUE,nBestLocations=1,type = "DNA",TH1 = 1,
                  maxMismatches = 0,indels = 0)
```

```
## 
##         ==========     _____ _    _ ____  _____  ______          _____  
##         =====         / ____| |  | |  _ \|  __ \|  ____|   /\   |  __ \ 
##           =====      | (___ | |  | | |_) | |__) | |__     /  \  | |  | |
##             ====      \___ \| |  | |  _ &lt;|  _  /|  __|   / /\ \ | |  | |
##               ====    ____) | |__| | |_) | | \ \| |____ / ____ \| |__| |
##         ==========   |_____/ \____/|____/|_|  \_\______/_/    \_\_____/
##        Rsubread 2.2.6
## 
## //================================= setting ==================================\\
## ||                                                                            ||
## || Function      : Read alignment (DNA-Seq)                                   ||
## || Input file    : Control_R1_S14_L008_R1_001_x.fastq.gz                      ||
## || Output file   : Control_R1_S14_L008_R1_001_x.bam (BAM)                     ||
## || Index name    : GeCKO                                                      ||
## ||                                                                            ||
## ||                    ------------------------------------                    ||
## ||                                                                            ||
## ||                               Threads : 4                                  ||
## ||                          Phred offset : 33                                 ||
## ||                             Min votes : 1 / 10                             ||
## ||                        Max mismatches : 0                                  ||
## ||                      Max indel length : 0                                  ||
## ||            Report multi-mapping reads : no                                 ||
## || Max alignments per multi-mapping read : 1                                  ||
## ||                                                                            ||
## \\============================================================================//
## 
## //================= Running (24-Aug-2020 17:00:37, pid=6141) =================\\
## ||                                                                            ||
## || Check the input reads.                                                     ||
## || The input file contains base space reads.                                  ||
## || Initialise the memory objects.                                             ||
## || Estimate the mean read length.                                             ||
## || The range of Phred scores observed in the data is [2,41]                   ||
## || Create the output BAM file.                                                ||
## || Check the index.                                                           ||
## || Init the voting space.                                                     ||
## || Global environment is initialised.                                         ||
## || Load the 1-th index block...                                               ||
## || The index block has been loaded.                                           ||
## || Start read mapping in chunk.                                               ||
## ||    5% completed, 0.4 mins elapsed, rate=196.0k reads per second            ||
## ||   12% completed, 0.4 mins elapsed, rate=210.2k reads per second            ||
## ||   19% completed, 0.4 mins elapsed, rate=215.4k reads per second            ||
## ||   26% completed, 0.4 mins elapsed, rate=217.5k reads per second            ||
## ||   32% completed, 0.4 mins elapsed, rate=219.6k reads per second            ||
## ||   39% completed, 0.4 mins elapsed, rate=220.1k reads per second            ||
## ||   45% completed, 0.4 mins elapsed, rate=219.8k reads per second            ||
## ||   54% completed, 0.4 mins elapsed, rate=219.7k reads per second            ||
## ||   61% completed, 0.5 mins elapsed, rate=220.1k reads per second            ||
## ||   69% completed, 0.5 mins elapsed, rate=12.6k reads per second             ||
## ||   73% completed, 0.5 mins elapsed, rate=13.1k reads per second             ||
## ||   77% completed, 0.5 mins elapsed, rate=13.7k reads per second             ||
## ||   80% completed, 0.5 mins elapsed, rate=14.2k reads per second             ||
## ||   83% completed, 0.5 mins elapsed, rate=14.6k reads per second             ||
## ||   87% completed, 0.5 mins elapsed, rate=15.1k reads per second             ||
## ||   89% completed, 0.5 mins elapsed, rate=15.4k reads per second             ||
## ||   92% completed, 0.5 mins elapsed, rate=15.9k reads per second             ||
## ||   96% completed, 0.5 mins elapsed, rate=16.3k reads per second             ||
## ||                                                                            ||
## ||                           Completed successfully.                          ||
## ||                                                                            ||
## \\====================================    ====================================//
## 
## //================================   Summary =================================\\
## ||                                                                            ||
## ||                 Total reads : 500,000                                      ||
## ||                      Mapped : 413,480 (82.7%)                              ||
## ||             Uniquely mapped : 413,480                                      ||
## ||               Multi-mapping : 0                                            ||
## ||                                                                            ||
## ||                    Unmapped : 86,520                                       ||
## ||                                                                            ||
## ||                      Indels : 0                                            ||
## ||                                                                            ||
## ||                Running time : 0.5 minutes                                  ||
## ||                                                                            ||
## \\============================================================================//
```

---
## Rsubread aligned data


```r
temp &lt;- readGAlignments(gsub(".fastq.gz",".bam",myFQs))
temp
```

```
## GAlignments object with 413480 alignments and 0 metadata columns:
##                seqnames strand       cigar    qwidth     start       end
##                   &lt;Rle&gt;  &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
##        [1] HGLibA_28034      +    29S20M1S        50         1        20
##        [2] HGLibA_47294      +    29S20M1S        50         1        20
##        [3] HGLibB_48743      +    29S20M1S        50         1        20
##        [4] HGLibA_43174      +    29S19M2S        50         1        19
##        [5] HGLibA_40957      +    29S19M2S        50         1        19
##        ...          ...    ...         ...       ...       ...       ...
##   [413476] HGLibB_34400      +    29S20M1S        50         1        20
##   [413477] HGLibA_56072      +    29S19M2S        50         1        19
##   [413478] HGLibA_28394      +    29S20M1S        50         1        20
##   [413479] HGLibA_08873      +    29S20M1S        50         1        20
##   [413480] HGLibB_53609      +    29S20M1S        50         1        20
##                width     njunc
##            &lt;integer&gt; &lt;integer&gt;
##        [1]        20         0
##        [2]        20         0
##        [3]        20         0
##        [4]        19         0
##        [5]        19         0
##        ...       ...       ...
##   [413476]        20         0
##   [413477]        19         0
##   [413478]        20         0
##   [413479]        20         0
##   [413480]        20         0
##   -------
##   seqinfo: 122411 sequences from an unspecified genome
```


---
## Rsubread aligned data


```r
table(grepl("29S20M1S",temp@cigar))
```

```
## 
##  FALSE   TRUE 
## 106622 306858
```

```r
temp &lt;- temp[grepl("29S20M1S",temp@cigar)]

# temp data.frame(table(seqnames(temp[width(temp) == "20"])),row.names = "Var1")
```

---
## Rsubread aligned data


```r
counts &lt;- data.frame(table(seqnames(temp)),row.names = "Var1")
counts &lt;- data.frame(table(seqnames(temp[width(temp) == "20"])),row.names = "Var1")
counts[1:2,,drop=FALSE]
```

```
##              Freq
## HGLibA_00001    0
## HGLibA_00002    0
```

---
## Rsubread aligned data


```r
download.file("http://pinapl-py.ucsd.edu/run/download/example-run","Results.zip")
unzip("Results.zip")
```


---
## Rsubread aligned data


```r
ss &lt;- read.delim("New_Example_1580342908_4/Analysis/01_Alignment_Results/ReadCounts_per_sgRNA/Control_1_GuideCounts.txt")
new &lt;- merge(ss,counts,by.x=1,by.y=0)
plot(new$X0,new$Freq)
```

![](crisprscreen_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

---
# Time for an exercise.

[Link_to_exercises](../../exercises/exercises/alignedData_exercise.html)

[Link_to_answers](../../exercises/answers/alignedData_answers.html)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
